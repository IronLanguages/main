/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Microsoft Public License. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the  Microsoft Public License, please send an email to 
 * dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Microsoft Public License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/

using System.Runtime.CompilerServices;
using System.Threading;

namespace System.Dynamic {
    internal static partial class UpdateDelegates {

        //
        // WARNING: do not edit these methods here. The real source code lives
        // in two places: generate_dynsites.py, which generates the methods in
        // this file, and UpdateDelegates.cs, which dynamically generates
        // methods like these at run time. If you want to make a change, edit
        // *both* of those files instead
        //

        #region Generated UpdateAndExecute Methods

        // *** BEGIN GENERATED CODE ***
        // generated by function: gen_update_targets from: generate_dynsites.py


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute0<TRet>(CallSite site) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, TRet>>)site;
            CallSiteRule<Func<CallSite, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, TRet>> rule;
            Func<CallSite, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] {  };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute1<T0, TRet>(CallSite site, T0 arg0) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, TRet>> rule;
            Func<CallSite, T0, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute2<T0, T1, TRet>(CallSite site, T0 arg0, T1 arg1) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, TRet>> rule;
            Func<CallSite, T0, T1, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute3<T0, T1, T2, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, TRet>> rule;
            Func<CallSite, T0, T1, T2, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute4<T0, T1, T2, T3, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute5<T0, T1, T2, T3, T4, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute6<T0, T1, T2, T3, T4, T5, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute7<T0, T1, T2, T3, T4, T5, T6, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute8<T0, T1, T2, T3, T4, T5, T6, T7, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute9<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return result;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site)) {
                        return result;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid1<T0>(CallSite site, T0 arg0) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0>>)site;
            CallSiteRule<Action<CallSite, T0>>[] applicable;
            CallSiteRule<Action<CallSite, T0>> rule;
            Action<CallSite, T0> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid2<T0, T1>(CallSite site, T0 arg0, T1 arg1) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1>>)site;
            CallSiteRule<Action<CallSite, T0, T1>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1>> rule;
            Action<CallSite, T0, T1> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid3<T0, T1, T2>(CallSite site, T0 arg0, T1 arg1, T2 arg2) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2>> rule;
            Action<CallSite, T0, T1, T2> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid4<T0, T1, T2, T3>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3>> rule;
            Action<CallSite, T0, T1, T2, T3> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid5<T0, T1, T2, T3, T4>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4>> rule;
            Action<CallSite, T0, T1, T2, T3, T4> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid6<T0, T1, T2, T3, T4, T5>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid7<T0, T1, T2, T3, T4, T5, T6>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid8<T0, T1, T2, T3, T4, T5, T6, T7>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ruleTarget, startingTarget = @this.Target;

            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            site = CallSiteOps.CreateMatchmaker();

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (int i = 0; i < applicable.Length; i++) {
                    rule = applicable[i];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    if ((object)startingTarget == (object)ruleTarget) {
                        // if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }else{                              
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

                        if (CallSiteOps.GetMatch(site)) {
                            CallSiteOps.UpdateRules(@this, i);
                            return;
                        }        

                        // Rule didn't match, try the next one
                        CallSiteOps.ClearMatch(site);            
                    }                
                }
            }

            //
            // Level 2 cache lookup
            //

            //
            // Any applicable rules in level 2 cache?
            //
            var cache = CallSiteOps.GetRuleCache(@this);

            applicable = CallSiteOps.FindApplicableRules(cache);
            for (int i = 0; i < applicable.Length; i++) {
                rule = applicable[i];

                //
                // Execute the rule
                //
                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // Rule worked. Add it to level 1 cache
                        //
                        CallSiteOps.AddRule(@this, rule);
                        // and then move it to the front of the L2 cache
                        CallSiteOps.MoveRule(cache, rule, i);
                    }
                }

                if ((object)startingTarget == (object)ruleTarget) {
                    // If we've gone megamorphic we can still template off the L2 cache
                    originalRule = rule;
                }

                // Rule didn't match, try the next one
                CallSiteOps.ClearMatch(site);
            }

            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(cache, @this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site)) {
                        return;
                    }
                } finally {
                    if (CallSiteOps.GetMatch(site)) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                CallSiteOps.ClearMatch(site);
            }
        }



        // *** END GENERATED CODE ***

        #endregion
    }
}
